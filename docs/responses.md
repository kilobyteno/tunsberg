All JSON responses generated by `tunsberg` follow the same envelope:

```json
{
  "status_code": 200,
  "message": "string",
  "data": {},
  "pagination": {}
}
```

Only `status_code` and `message` are guaranteed to be present.

---

## Basic usage

Import the response helpers in your FastAPI endpoints:

```python
from tunsberg.responses import (
    response_success,
    response_created,
    response_no_content,
    response_bad_request,
    response_not_found,
)
```

---

## Success responses

### Single resource

```python
@router.get("/vehicle-types/{key}")
def get_vehicle_type(key: str):
    vehicle_type = {"key": "car", "name": "Car"}

    return response_success(
        message="Vehicle type retrieved successfully.",
        data=vehicle_type,
    )
```

Response:

```json
{
  "status_code": 200,
  "message": "Vehicle type retrieved successfully.",
  "data": {
    "key": "car",
    "name": "Car"
  }
}
```

---

### Multiple resources

```python
@router.get("/vehicle-types")
def list_vehicle_types():
    vehicle_types = [
        {"key": "car", "name": "Car"},
        {"key": "motorcycle", "name": "Motorcycle"},
    ]

    return response_success(
        message="Vehicle types retrieved successfully.",
        data=vehicle_types,
    )
```

Response:

```json
{
  "status_code": 200,
  "message": "Vehicle types retrieved successfully.",
  "data": [
    { "key": "car", "name": "Car" },
    { "key": "motorcycle", "name": "Motorcycle" }
  ]
}
```

---

## Created responses

Use `response_created` when a resource is created.

```python
@router.post("/vehicle-types")
def create_vehicle_type(payload: dict):
    return response_created(
        message="Vehicle type created successfully.",
        data=payload,
    )
```

Response:

```json
{
  "status_code": 201,
  "message": "Vehicle type created successfully.",
  "data": {
    "key": "car",
    "name": "Car"
  }
}
```

---

## No content responses

Use `response_no_content` when an operation succeeds but returns no payload.

```python
@router.delete("/vehicle-types/{key}")
def delete_vehicle_type(key: str):
    return response_no_content()
```

Response:

```
HTTP/1.1 204 No Content
```

---

## Pagination

Use `response_pagination` for paginated collection endpoints.

```python
from tunsberg.responses import response_pagination

@router.get("/parking-areas")
def list_parking_areas(page: Page):
    return response_pagination(
        message="Parking areas successfully fetched",
        data=[],
        pagination=page,
    )
```

Response:

```json
{
  "status_code": 200,
  "message": "Parking areas successfully fetched",
  "data": [],
  "pagination": {
    "total": 0,
    "page": 1,
    "size": 10,
    "pages": 0
  }
}
```

---

## Error responses

### Bad request

```python
return response_bad_request(
    message="Invalid vehicle type",
    data={"field": "key"},
)
```

Response:

```json
{
  "status_code": 400,
  "message": "Invalid vehicle type",
  "data": {
    "field": "key"
  }
}
```

---

### Not found

```python
return response_not_found("Vehicle type not found")
```

Response:

```json
{
  "status_code": 404,
  "message": "Vehicle type not found"
}
```

---

## Custom responses

Use `response_custom` if none of the predefined helpers fit.

```python
from tunsberg.responses import response_custom

return response_custom(
    message="Rate limit exceeded",
    status_code=429,
    data={"retry_after": 30},
)
```

---

## Background tasks

`tunsberg` supports FastAPI background tasks through the response helpers.

```python
return response_success(
    message="Email queued",
    data={"queued": True},
    background_tasks=background_tasks,
)
```

---

## Rules and recommendations

* Always use the provided response helpers
* Do not return raw dictionaries or `JSONResponse` directly
* Use lists for collections and objects for single resources
* Use pagination only for collection endpoints
* Keep messages human-readable and consistent
